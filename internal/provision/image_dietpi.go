package provision

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"io"
	"os"
	"path/filepath"
)

// DietPiProvider provides DietPi OS images
type DietPiProvider struct {
	version string
}

// NewDietPiProvider creates a new DietPi provider
func NewDietPiProvider() *DietPiProvider {
	return &DietPiProvider{
		version: "9.8", // Latest stable version
	}
}

// GetImageURL returns the download URL for DietPi
func (p *DietPiProvider) GetImageURL(arch string) (string, error) {
	// Map architecture to DietPi naming
	// DietPi direct download URLs from dietpi.com
	var imageFile string
	switch arch {
	case "arm64", "aarch64":
		// Raspberry Pi 3/4/5 64-bit
		imageFile = "DietPi_RPi-ARMv8-Bookworm.7z"
	case "armv7", "armhf", "arm":
		// Raspberry Pi 2/3 32-bit  
		imageFile = "DietPi_RPi-ARMv7-Bookworm.7z"
	case "armv6":
		// Raspberry Pi 1/Zero
		imageFile = "DietPi_RPi-ARMv6-Bookworm.7z"
	default:
		return "", fmt.Errorf("unsupported architecture for DietPi: %s", arch)
	}
	
	// Use DietPi's direct download server
	return fmt.Sprintf("https://dietpi.com/downloads/images/%s", imageFile), nil
}

// GetImageName returns the name of this image
func (p *DietPiProvider) GetImageName() string {
	return fmt.Sprintf("dietpi-%s", p.version)
}

// ValidateImage validates the downloaded DietPi image
func (p *DietPiProvider) ValidateImage(imagePath string) error {
	// For now, just check if file exists and is not empty
	// In production, we'd verify checksums from DietPi's SHA256 files
	fi, err := os.Stat(imagePath)
	if err != nil {
		return err
	}
	
	if fi.Size() == 0 {
		return fmt.Errorf("image file is empty")
	}
	
	// TODO: Download and verify SHA256 checksum from DietPi
	return nil
}

// GetBootPartitionLabel returns the boot partition label
func (p *DietPiProvider) GetBootPartitionLabel() string {
	return "boot"
}

// GetRootPartitionLabel returns the root partition label
func (p *DietPiProvider) GetRootPartitionLabel() string {
	return "rootfs"
}

// PostWriteSetup performs DietPi-specific setup
func (p *DietPiProvider) PostWriteSetup(bootPath, rootPath string, config *Config) error {
	// Create dietpi.txt for automated setup
	if err := p.writeDietPiConfig(bootPath, config); err != nil {
		return fmt.Errorf("failed to write dietpi.txt: %w", err)
	}
	
	// Create dietpi-wifi.txt if WiFi is configured
	if config.Network.WiFiSSID != "" {
		if err := p.writeDietPiWiFi(bootPath, config); err != nil {
			return fmt.Errorf("failed to write dietpi-wifi.txt: %w", err)
		}
	}
	
	// Enable SSH if configured
	if config.Security.EnableSSH {
		// Create ssh file to enable SSH on first boot
		sshFile := filepath.Join(bootPath, "ssh")
		if err := os.WriteFile(sshFile, []byte(""), 0644); err != nil {
			return fmt.Errorf("failed to enable SSH: %w", err)
		}
		
		// Add SSH key if provided
		if config.Security.SSHKey != "" {
			if err := p.setupSSHKey(rootPath, config.Security.SSHKey); err != nil {
				return fmt.Errorf("failed to setup SSH key: %w", err)
			}
		}
	}
	
	// Write fleetd configuration
	if err := p.writeFleetdConfig(bootPath, config); err != nil {
		return fmt.Errorf("failed to write fleetd config: %w", err)
	}
	
	// Create custom script for first boot
	if err := p.writeFirstBootScript(bootPath, config); err != nil {
		return fmt.Errorf("failed to write first boot script: %w", err)
	}
	
	return nil
}

// writeDietPiConfig creates the dietpi.txt configuration file
func (p *DietPiProvider) writeDietPiConfig(bootPath string, config *Config) error {
	// DietPi automated setup configuration
	dietpiConfig := fmt.Sprintf(`# DietPi Configuration
# Generated by fleetd provisioner

# Automation
AUTO_SETUP_AUTOMATED=1
AUTO_SETUP_NET_ETHERNET_ENABLED=1
AUTO_SETUP_NET_WIFI_ENABLED=%d
AUTO_SETUP_NET_WIFI_COUNTRY_CODE=US
AUTO_SETUP_DHCP_TO_STATIC=0
AUTO_SETUP_NET_HOSTNAME=%s
AUTO_SETUP_BOOT_WAIT_FOR_NETWORK=1
AUTO_SETUP_SSH_SERVER_INDEX=-2
AUTO_SETUP_LOGGING_INDEX=0
AUTO_SETUP_CUSTOM_SCRIPT_EXEC=/boot/fleetd-setup.sh
AUTO_SETUP_LOCALE=en_US.UTF-8
AUTO_SETUP_KEYBOARD_LAYOUT=us
AUTO_SETUP_TIMEZONE=UTC
SOFTWARE_DISABLE_SSH_PASSWORD_LOGINS=%d

# Performance
CONFIG_CPU_GOVERNOR=ondemand
CONFIG_CPU_ONDEMAND_SAMPLE_RATE=25000
CONFIG_CPU_ONDEMAND_SAMPLE_DOWNFACTOR=10

# Software selection
AUTO_SETUP_INSTALL_SOFTWARE_ID=0
`, 
		boolToInt(config.Network.WiFiSSID != ""),
		config.DeviceName,
		boolToInt(config.Security.SSHKey != ""),
	)
	
	configPath := filepath.Join(bootPath, "dietpi.txt")
	return os.WriteFile(configPath, []byte(dietpiConfig), 0644)
}

// writeDietPiWiFi creates the WiFi configuration
func (p *DietPiProvider) writeDietPiWiFi(bootPath string, config *Config) error {
	wifiConfig := fmt.Sprintf(`# WiFi Configuration
# Generated by fleetd provisioner

aWIFI_SSID[0]='%s'
aWIFI_KEY[0]='%s'
aWIFI_KEYMGR[0]='WPA-PSK'
`, config.Network.WiFiSSID, config.Network.WiFiPass)
	
	wifiPath := filepath.Join(bootPath, "dietpi-wifi.txt")
	return os.WriteFile(wifiPath, []byte(wifiConfig), 0644)
}

// setupSSHKey adds an SSH public key for the root user
func (p *DietPiProvider) setupSSHKey(rootPath string, sshKey string) error {
	// Create .ssh directory for root user
	sshDir := filepath.Join(rootPath, "root", ".ssh")
	if err := os.MkdirAll(sshDir, 0700); err != nil {
		return err
	}
	
	// Write authorized_keys
	authKeysPath := filepath.Join(sshDir, "authorized_keys")
	return os.WriteFile(authKeysPath, []byte(sshKey), 0600)
}

// writeFleetdConfig writes the fleetd agent configuration
func (p *DietPiProvider) writeFleetdConfig(bootPath string, config *Config) error {
	fleetdYAML := fmt.Sprintf(`# FleetD Agent Configuration
agent:
  id: %s
  name: %s
  type: %s

discovery:
  enabled: true
  mdns:
    enabled: true
    service: "_fleetd._tcp"
    port: 8080

telemetry:
  enabled: true
  interval: 60s
`, config.DeviceID, config.DeviceName, config.DeviceType)
	
	if config.Fleet.ServerURL != "" {
		fleetdYAML += fmt.Sprintf(`
server:
  url: %s
`, config.Fleet.ServerURL)
	}
	
	configPath := filepath.Join(bootPath, "fleetd.yaml")
	return os.WriteFile(configPath, []byte(fleetdYAML), 0644)
}

// writeFirstBootScript creates a script that runs on first boot
func (p *DietPiProvider) writeFirstBootScript(bootPath string, config *Config) error {
	script := `#!/bin/bash
# FleetD First Boot Setup Script

echo "Starting fleetd setup..."

# Wait for network
while ! ping -c 1 -W 1 8.8.8.8 &> /dev/null; do
    echo "Waiting for network..."
    sleep 2
done

# Download and install fleetd
ARCH=$(uname -m)
case $ARCH in
    aarch64) ARCH="arm64" ;;
    armv7l)  ARCH="armv7" ;;
    armv6l)  ARCH="armv6" ;;
esac

echo "Downloading fleetd for $ARCH..."
wget -q -O /tmp/fleetd "https://github.com/fleetd-sh/fleetd/releases/latest/download/fleetd-linux-$ARCH"
chmod +x /tmp/fleetd
mv /tmp/fleetd /usr/local/bin/fleetd

# Copy configuration
mkdir -p /etc/fleetd
cp /boot/fleetd.yaml /etc/fleetd/config.yaml

# Create systemd service
cat > /etc/systemd/system/fleetd.service << 'EOF'
[Unit]
Description=FleetD Agent
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=/usr/local/bin/fleetd agent --config /etc/fleetd/config.yaml
Restart=always
RestartSec=10
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
EOF

# Enable and start fleetd
systemctl daemon-reload
systemctl enable fleetd
systemctl start fleetd

echo "FleetD setup complete!"
`
	
	// Add k3s installation if configured
	if plugins, ok := config.Plugins["k3s"].(map[string]any); ok {
		role, _ := plugins["role"].(string)
		if role == "server" {
			script += `
# Install k3s server
curl -sfL https://get.k3s.io | sh -s - server --write-kubeconfig-mode 644
`
		} else if role == "agent" {
			serverURL, _ := plugins["server"].(string)
			token, _ := plugins["token"].(string)
			script += fmt.Sprintf(`
# Install k3s agent
curl -sfL https://get.k3s.io | K3S_URL=%s K3S_TOKEN=%s sh -
`, serverURL, token)
		}
	}
	
	scriptPath := filepath.Join(bootPath, "fleetd-setup.sh")
	return os.WriteFile(scriptPath, []byte(script), 0755)
}

// boolToInt converts a boolean to 0 or 1
func boolToInt(b bool) int {
	if b {
		return 1
	}
	return 0
}

// calculateSHA256 calculates the SHA256 checksum of a file
func calculateSHA256(filepath string) (string, error) {
	file, err := os.Open(filepath)
	if err != nil {
		return "", err
	}
	defer file.Close()
	
	hash := sha256.New()
	if _, err := io.Copy(hash, file); err != nil {
		return "", err
	}
	
	return hex.EncodeToString(hash.Sum(nil)), nil
}